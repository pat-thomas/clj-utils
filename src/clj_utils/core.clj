(ns clj-utils.core
  (:require [clj-utils.core-helpers :refer :all]))

(defmacro defcurried
  [fn-name args-list & body]
  (let [args-list->args-lists-for-defcurried (fn [args-list]
                                               (for [n (->> args-list count inc range)]
                                                 (vec (take n args-list))))
        gen-arity                            (fn [fn-name args-list]
                                               `(~args-list
                                                 (partial ~fn-name ~@args-list)))
        args-lists                           (args-list->args-lists-for-defcurried args-list)
        partial-args-lists                   (drop-last args-lists)
        full-args-list                       (last args-lists)]
    `(defn ~fn-name
       ~@(map (fn [partial-args-list]
                (gen-arity fn-name partial-args-list))
              partial-args-lists)
       (~full-args-list ~@body))))

(defmacro deftransform
  [transform-name & body]
  (let [autogenerated-args (identify-numbered-autogen-args body)]
    `(do ~@(concat
            (->> body
                 (partition 2)
                 (map (fn [[fn-name# fn-body#]]
                        `(defcurried ~fn-name#
                           ~autogenerated-args
                           ~fn-body#))))
            (list `(defcurried ~transform-name
                     ~autogenerated-args
                     ~(concat (if (vector? autogenerated-args)
                                (list '-> autogenerated-args)
                                (flatten (list '-> autogenerated-args)))
                              (->> body
                                   (partition 2)
                                   (map first)))))))))


(defmacro defn-with-nil-protection
  [fn-name args-list & body]
  `(defn ~fn-name
     ~args-list
     (assert (every? true? (map (comp not nil?) ~args-list)))
     ~@body))
